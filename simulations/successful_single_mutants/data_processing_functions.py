"""Functions for processing data from single mutant simulations.

Data to be read in must be generated by the successful_single_mutant program.
"""
import numpy as np
from numpy.lib.recfunctions import append_fields

def merge_data(filename, tfinal=False, sortby='m'):
    """Combine the data from multiple job output files into one array.

    tfinal -- whether or not to include tfinal in the output array. If false,
        data with different tfinals will be merged together, which may be
        misleading when some runs were segregating at time tfinal.
    sortby --- field to sort output array by
    """
    # Load in raw data from 'filename', assumed to have format
    # Li Lj N mu1 delta s mi mj m tfinal seed num_runs num_success num_seg
    raw_dtype=[('Li', np.int_), ('Lj', np.int_), ('N', np.int_),
            ('mu1', np.float_), ('delta', np.float_), ('s', np.float_), 
            ('mi', np.float_), ('mj', np.float_), ('m', np.float_), 
            ('tfinal', np.int_), ('seed', np.int_), 
            ('num_runs', np.int_), ('num_success', np.int_), 
            ('num_seg', np.int_)]
    raw_data = np.loadtxt(filename, dtype=raw_dtype, delimiter=' ')
    # Sort by field chosen in arg sortby
    raw_data.sort(order=sortby)
    # Consolidate the data by averaging the results from all runs with the same
    # parameters. Store the consolidated data in the array 'merged'
    if tfinal:
        merged_dtype=[('Li', np.int_), ('Lj', np.int_), ('N', np.int_),
                ('mu1', np.float_), ('delta', np.float_), ('s', np.float_), 
                ('mi', np.float_), ('mj', np.float_), ('m', np.float_), 
                ('tfinal', np.int_),
                ('num_runs', np.int_), ('num_success', np.int_), 
                ('num_seg', np.int_)]
        merged = np.zeros((len(raw_data),), dtype=merged_dtype)
        # Enter one row into the merged array for each unique paramter set
        merged_index = 0
        for i in range(len(raw_data)):
            # Check if row represents a new set of parameters
            params = raw_data[['Li', 'Lj', 'N', 'mu1', 'delta', 's', 'mi',
                'mj', 'm', 'tfinal']][i]
            # Check if at least one matching row in merged
            exists = ( 0 < sum(merged[['Li', 'Lj', 'N', 'mu1', 'delta', 's',
                'mi', 'mj', 'm', 'tfinal']] == params) )
            # If a new parameter set, filter out all runs for that parameter
            # set, combine their results, and store as a new entry in the
            # merged results array
            if not exists:
                matching_row_indices = (raw_data[['Li', 'Lj', 'N', 'mu1',
                    'delta', 's', 'mi', 'mj', 'm', 'tfinal']] == params)
                filtered = raw_data[matching_row_indices]
                tot_num_runs = sum(filtered['num_runs'])
                tot_num_success = sum(filtered['num_success'])
                tot_num_seg = sum(filtered['num_seg'])
                # Record results
                merged[merged_index] = tuple(params) + (tot_num_runs,
                        tot_num_success, tot_num_seg)
                print(merged[merged_index])
                merged_index += 1
        # Trim the unneeded rows from the merged array
        merged_trimmed = merged[0:merged_index]
        return merged_trimmed
    else:
        merged_dtype=[('Li', np.int_), ('Lj', np.int_), ('N', np.int_),
                ('mu1', np.float_), ('delta', np.float_), ('s', np.float_), 
                ('mi', np.float_), ('mj', np.float_), ('m', np.float_), 
                ('num_runs', np.int_), ('num_success', np.int_), 
                ('num_seg', np.int_)]
        merged = np.zeros((len(raw_data),), dtype=merged_dtype)
        # Enter one row into the merged array for each unique paramter set
        merged_index = 0
        for i in range(len(raw_data)):
            # Check if row represents a new set of parameters
            params = raw_data[['Li', 'Lj', 'N', 'mu1', 'delta', 's', 'mi',
                'mj', 'm']][i]
            # Check if at least one matching row in merged
            exists = ( 0 < sum(merged[['Li', 'Lj', 'N', 'mu1', 'delta', 's',
                'mi', 'mj', 'm']] == params) )
            # If a new parameter set, filter out all runs for that parameter
            # set, combine their results, and store as a new entry in the
            # merged results array
            if not exists:
                matching_row_indices = (raw_data[['Li', 'Lj', 'N', 'mu1',
                    'delta', 's', 'mi', 'mj', 'm']] == params)
                filtered = raw_data[matching_row_indices]
                tot_num_runs = sum(filtered['num_runs'])
                tot_num_success = sum(filtered['num_success'])
                tot_num_seg = sum(filtered['num_seg'])
                # Record results
                merged[merged_index] = tuple(params) + (tot_num_runs,
                        tot_num_success, tot_num_seg)
                print(merged[merged_index])
                merged_index += 1
        # Trim the unneeded rows from the merged array
        merged_trimmed = merged[0:merged_index]
        return merged_trimmed

def read_times(filename, summary=False):
    """Get the drift and sweep times of successful lineages from a file.

    Lines beginning with '#' in filename are skipped.
    t1 is the time when the successful 2-mutant is generated.
    tsw is the time for the successful 2-mutant to fix in the population since
    being generated.
    """
    in_dtype = [('n0', np.int_), ('n1', np.int_), ('n2', np.int_), 
            ('t1', np.int_), ('tsw', np.int_)]
    df = np.loadtxt(filename, dtype=in_dtype, delimiter=' ')
    # The time that is read in for tsw is actually the time from the beginning
    # of the simulation until the 2-mutant is fixed, so need to subtract off
    # the drift time
    df['tsw'] = df['tsw'] - df['t1']
    if not summary:
        return df[['t1', 'tsw']]
    else:
        sum_dtype = [('t1', np.float_), ('t1_se', np.float_), ('tsw',
            np.float_), ('tsw_se', np.float_)]
        sum_df = np.empty((1,), dtype=sum_dtype)
        t1 = df['t1']
        tsw = df['tsw']
        sum_df['t1'] = np.mean(t1)
        sum_df['t1_se'] = np.std(t1, ddof=1) / np.sqrt(len(t1))
        sum_df['tsw'] = np.mean(tsw)
        sum_df['tsw_se'] = np.std(tsw, ddof=1) / np.sqrt(len(tsw))
        return sum_df

